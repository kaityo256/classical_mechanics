<!DOCTYPE html>
<html>

    <head>
        <meta charset="utf-8">
        <meta name="generator" content="pandoc">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
                                <title>数学的準備</title>

        <style>
            .btn-square {
                display: inline-block;
                padding: 0.5em 0.5em;
                text-decoration: none;
                background: #668ad8;
                color: #FFF;
                border-bottom: solid 4px #626295;
                border-radius: 5px;
            }

            .btn-square:active {
                -webkit-transform: translateY(4px);
                transform: translateY(4px);
                border-bottom: none;
            }

            .markdown-body {
                box-sizing: border-box;
                min-width: 200px;
                max-width: 980px;
                margin: 0 auto;
                padding: 45px;
            }

            @media (max-width: 767px) {
                .markdown-body {
                    padding: 15px;
                }
            }
        </style>

        <meta name="viewport" content="width=device-width, initial-scale=1">

                <script
                src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
                type="text/javascript"></script>
                        <link href="https://use.fontawesome.com/releases/v5.6.1/css/all.css" rel="stylesheet">
        <link rel="icon" href="https://kaityo256.github.io/classical_mechanics/favicon.ico">
        <link rel="stylesheet" href="https://kaityo256.github.io/classical_mechanics/github-markdown.css"
            type="text/css" />
    </head>

    <body>
        <article class="markdown-body">
                                    <header>
                <h1 class="title">数学的準備</h1>
                                                            </header>
                                    <p><a href="../index.html">[Up]</a>
                                    <a
                                    href="https://github.com/kaityo256/classical_mechanics">[Repository]</a></p>
                                    <p>解析力学を学ぶ前に、必要な数学的準備を済ませよう。解析力学には、ベクトルや座標変換といった線形代数、微分、偏微分、ルジャンドル変換、微分形式、汎関数微分など、多種多様な数学的ツールが現れる。特に、数学の主要三分野である解析、代数、幾何の全てが現れるのが解析力学の難しいところであり、また面白いところでもある。以下では、特にベクトル空間及び内積空間の導入と、微分とベクトルがからむベクトル解析についてまとめておく。</p>
                                    <h1
                                    id="ベクトル空間">ベクトル空間</h1>
                                    <h2
                                    id="ベクトルの表記">ベクトルの表記</h2>
                                    <p>我々は3次元空間に住んでいるため、力学でも3次元空間中の運動を扱うことが多い。3次元空間中では、質点の位置を指定したり、速度や力を指定したりするのに3つの数字の組が必要になる。例えば、ある質点の座標が<span
                                    class="math inline">\((r_x,r_y,r_z)\)</span>である時、</p>
                                    <p><span class="math display">\[
                                    \mathbf{r} =
                                    \begin{pmatrix}
                                    r_x\\
                                    r_y\\
                                    r_z
                                    \end{pmatrix}
                                    \]</span></p>
                                    <p>とまとめて表記する。このように、いくつかの数字の組で表現される量を
                                    <strong>ベクトル(vector)</strong>
                                    と呼ぶ。特に、<span
                                    class="math inline">\(\mathbf{r}\)</span>
                                    は位置ベクトルと呼ばれる。同様に速度ベクトルなどが定義される。本講義ノートでは<span
                                    class="math inline">\(\mathbf{r}\)</span>のように太字で表記する。板書においては、通常のアルファベットに縦線を一本加えることで太字を表現する。ベクトルは大きさと向きを持つ量である。板書では縦ベクトルは縦に書くが、講義ノートでは紙面の都合から横に書きたいことがある。その場合は<span
                                    class="math inline">\(\mathbf{r} =
                                    {}^t(r_x, r_y,
                                    r_z)\)</span>のように、ベクトルの最初に<span
                                    class="math inline">\(t\)</span>をつけて表す。この<span
                                    class="math inline">\(t\)</span>は転置を表し、横ベクトルを転置することで、縦ベクトルであることを表現している。</p>
                                    <p>一方、ベクトルではない普通の数を
                                    <strong>スカラー(scalar)</strong>
                                    と呼ぶ。ベクトルと違い、スカラーは向きを持たず大きさのみを持つ。</p>
                                    <h2
                                    id="基底ベクトルと内積">基底ベクトルと内積</h2>
                                    <p>力学におけるベクトルで重要なのは、座標変換によるベクトルの変換である。先程のベクトル表記では、数を3つ縦に並べた。これは、以下のように書き直すことができる。</p>
                                    <p><span class="math display">\[
                                    \mathbf{r} =
                                    r_x
                                    \begin{pmatrix}
                                    1\\
                                    0\\
                                    0
                                    \end{pmatrix}
                                    +
                                    r_y
                                    \begin{pmatrix}
                                    0\\
                                    1\\
                                    0
                                    \end{pmatrix}
                                    +
                                    r_y
                                    \begin{pmatrix}
                                    0\\
                                    0\\
                                    1
                                    \end{pmatrix}
                                    \]</span></p>
                                    <p>3つの基本的なベクトルの和にわけることができた。これらのベクトルを<span
                                    class="math inline">\(\mathbf{e}_x,\mathbf{e}_y,\mathbf{e}_z\)</span>と書こう。すると、</p>
                                    <p><span class="math display">\[
                                    \mathbf{r} = r_x \mathbf{e_x} + r_y
                                    \mathbf{e_y} + r_z \mathbf{e_z}
                                    \]</span></p>
                                    <p>と表記できる。この時、<span
                                    class="math inline">\(\mathbf{e}_x,\mathbf{e}_y,\mathbf{e}_z\)</span>を基底ベクトル、あるいは単に
                                    <strong>基底(basis)</strong>
                                    と呼び、この式を基底ベクトルによる展開と呼ぶ。特に、</p>
                                    <p><span class="math display">\[
                                    \mathbf{e}_x =
                                    \begin{pmatrix}
                                    1\\
                                    0\\
                                    0
                                    \end{pmatrix},
                                    \mathbf{e}_y =
                                    \begin{pmatrix}
                                    0\\
                                    1\\
                                    0
                                    \end{pmatrix},
                                    \mathbf{e}_z =
                                    \begin{pmatrix}
                                    0\\
                                    0\\
                                    1
                                    \end{pmatrix}
                                    \]</span></p>
                                    <p>のように、成分の一つだけが1、残りが0となるような基底を標準基底と呼ぶ。</p>
                                    <p><span class="math display">\[
                                    \mathbf{r} =
                                    \begin{pmatrix}
                                    r_x\\
                                    r_y\\
                                    r_z
                                    \end{pmatrix}
                                    \]</span>
                                    という表記は、標準基底ベクトル<span
                                    class="math inline">\(\mathbf{e}_x,\mathbf{e}_y,\mathbf{e}_z\)</span>を採用した時のベクトル<span
                                    class="math inline">\(\mathbf{r}\)</span>の展開表現である。</p>
                                    <p>すなわち、本来なら</p>
                                    <p><span class="math display">\[
                                    \mathbf{r} = r_x \mathbf{e_x} + r_y
                                    \mathbf{e_y} + r_z \mathbf{e_z}
                                    \]</span></p>
                                    <p>と書くべきところを、基底ベクトルを<span
                                    class="math inline">\(\mathbf{e}_x,\mathbf{e}_y,\mathbf{e}_z\)</span>と暗黙に仮定した上で括弧で略記した記法である。</p>
                                    <p>ベクトルの要素表示は、基底を定めて初めて決まるものである。物理においては、物理法則が座標系に依存しないという要請をする。したがって、まずベクトルがあり、座標系を決めると要素が決まる、という順序となる。</p>
                                    <p>さて、今は<span
                                    class="math inline">\(\mathbf{e}_x\)</span>などが簡単な形をしているため、<span
                                    class="math inline">\(\mathbf{r}\)</span>を<span
                                    class="math inline">\(\mathbf{e}_x\)</span>などで展開した時の係数が簡単に求まった。しかし、一般のベクトルを基底ベクトルにした場合、その展開係数を求めるのは面倒である。そこで、ベクトルの内積により展開係数を求める。</p>
                                    <p>基底ベクトル<span
                                    class="math inline">\(\mathbf{e}_x,\mathbf{e}_y,\mathbf{e}_z\)</span>は、要素が縦に並んでいる縦ベクトルであった。これらの対になるベクトルとして、以下の横ベクトルを定義する。</p>
                                    <p><span class="math display">\[
                                    \begin{aligned}
                                    \mathbf{e}^x =
                                    \begin{pmatrix}
                                    1 &amp; 0 &amp; 0
                                    \end{pmatrix} \\
                                    \mathbf{e}^y =
                                    \begin{pmatrix}
                                    0 &amp; 1 &amp; 0
                                    \end{pmatrix} \\
                                    \mathbf{e}^z =
                                    \begin{pmatrix}
                                    0 &amp; 0 &amp; 1
                                    \end{pmatrix}
                                    \end{aligned}
                                    \]</span></p>
                                    <p>縦ベクトルの添字を下に、横ベクトルの添字を上につけている。縦ベクトルと横ベクトルの間には内積を定義することができる。</p>
                                    <p>例えば、<span
                                    class="math inline">\(\mathbf{e}^x\)</span>と<span
                                    class="math inline">\(\mathbf{e}_x\)</span>の内積を取ると</p>
                                    <p><span class="math display">\[
                                    (\mathbf{e}^x, \mathbf{e}_x) =
                                    \begin{pmatrix}
                                    1 &amp; 0 &amp; 0
                                    \end{pmatrix}
                                    \begin{pmatrix}
                                    1\\
                                    0\\
                                    0
                                    \end{pmatrix}
                                    = 1
                                    \]</span></p>
                                    <p>同様に、<span
                                    class="math inline">\(\mathbf{e}^x\)</span>と<span
                                    class="math inline">\(\mathbf{e}_y\)</span>の内積を取ると</p>
                                    <p><span class="math display">\[
                                    (\mathbf{e}^x, \mathbf{e}_y) =
                                    \begin{pmatrix}
                                    1 &amp; 0 &amp; 0
                                    \end{pmatrix}
                                    \begin{pmatrix}
                                    0\\
                                    1\\
                                    0
                                    \end{pmatrix}
                                    = 0
                                    \]</span>
                                    つまり、添字が同じであれば1に、異なれば0になる。</p>
                                    <p>いちいち座標を<span
                                    class="math inline">\(x,y,z\)</span>と書いていると、特に和を取る時に不便なので、以下<span
                                    class="math inline">\(\mathbf{e}_x,\mathbf{e}_y,\mathbf{e}_z\)</span>を、それぞれ<span
                                    class="math inline">\(\mathbf{e}_1,\mathbf{e}_2,\mathbf{e}_3\)</span>と表記しよう。相方となる基底<span
                                    class="math inline">\(\mathbf{e}^1,\mathbf{e}^2,\mathbf{e}^3\)</span>も同様である。この表記を用いると、先程の内積は以下のようにまとめて書ける。</p>
                                    <p><span class="math display">\[
                                    (\mathbf{e}^i, \mathbf{e}_j) =
                                    \delta^i_j
                                    \]</span></p>
                                    <p>内積がゼロであることを
                                    <strong>直交(orthogonal)</strong>
                                    していると呼ぶ。自分の相方が決まっており、相方以外との内積が全てゼロになるような基底を
                                    <strong>直交基底(orthogonal
                                    basis)</strong>
                                    と呼ぶ。さらに相方との内積が1に規格化されている基底を
                                    <strong>正規直交基底(orthonormal
                                    basis)</strong>
                                    と呼ぶ。基底として正規直交基底を選ぶと、任意の基底で表現されたベクトルを、別の基底で表現した時の成分が簡単に求まる、という利点がある。</p>
                                    <p>なお、添え字の上下はきちんと区別すべきものであるが、表記が煩雑になる場合がある。例えば座標の成分は<span
                                    class="math inline">\(q^i\)</span>など上付きにすべきだが、そうすると座標の二乗を<span
                                    class="math inline">\((q^i)^2\)</span>などと表記する必要がある。本書では、上下の区別が重要である場合を除いて物理量の添え字は下につける。</p>
                                    <p>一般に、あるベクトルと、内積をとる相手のベクトルの住む空間は異なる。自分が住む空間から見て、内積を取る相手が住む空間を
                                    <strong>双対空間(dual
                                    space)</strong>
                                    と呼ぶ。双対空間はお互い様であり、縦ベクトルから見れば横ベクトルが住む空間が双対空間だが、横ベクトルから見れば縦ベクトルが住む空間が双対空間である。また、ある基底と内積をとる相方の基底のことを双対基底と呼ぶ。双対基底は、双対空間に住んでいる基底である。</p>
                                    <p>ここまではベクトルが住む空間がわかりやすいように、住む世界を添え字の上下で区別したが、2つの空間を区別する必要がない場合は2つのベクトル<span
                                    class="math inline">\(\mathbf{a} =
                                    {}^t(a_1, a_2, a_3)\)</span>と<span
                                    class="math inline">\(\mathbf{b} =
                                    {}^t(b_1, b_2,
                                    b_3)\)</span>の内積を</p>
                                    <p><span class="math display">\[
                                    \begin{aligned}
                                    \mathbf{a} \cdot \mathbf{b}
                                    &amp;\equiv ({}^t \mathbf{a},
                                    \mathbf{b}) \\
                                    &amp;= a_1 b_1 + a_2 b_2 + a_3 b_3
                                    \\
                                    &amp;= \sum_i^{3} a_i b_j
                                    \end{aligned}
                                    \]</span></p>
                                    <p>とドット表記で書く場合もある。以後、内積の表記法としてドット表記<span
                                    class="math inline">\(\mathbf{a}
                                    \cdot
                                    \mathbf{b}\)</span>と括弧表記<span
                                    class="math inline">\((\mathbf{a} ,
                                    \mathbf{b})\)</span>の両方を使う。</p>
                                    <p>さて、ある基底<span
                                    class="math inline">\(\mathbf{e}_i\)</span>が正規直交基底であるとする。ベクトル<span
                                    class="math inline">\(\mathbf{r}\)</span>と基底との内積が、</p>
                                    <p><span class="math display">\[
                                    \begin{aligned}
                                    \mathbf{r} \cdot \mathbf{e_1} &amp;=
                                    r_1 \\
                                    \mathbf{r} \cdot \mathbf{e_2} &amp;=
                                    r_2 \\
                                    \mathbf{r} \cdot \mathbf{e_3} &amp;=
                                    r_3
                                    \end{aligned}
                                    \]</span></p>
                                    <p>で与えられている時、この基底でベクトルが以下のように展開できる。</p>
                                    <p><span class="math display">\[
                                    \mathbf{r} = r_1 \mathbf{e_1} + r_2
                                    \mathbf{e_2} + r_3 \mathbf{e_3}
                                    \]</span></p>
                                    <p>繰り返しとなるが、物理においては特定の座標を特別視しないため、まず座標系に依存しないベクトルが存在し、必要に応じて座標系を定義すると、内積によってその展開係数が決まる、というイメージを持つとよい。</p>
                                    <p>さて、ある基底<span
                                    class="math inline">\(\mathbf{e}_1,
                                    \mathbf{e}_2,
                                    \mathbf{e}_3\)</span>で表現されたベクトル<span
                                    class="math inline">\(\mathbf{r} =
                                    {}^t(r_1, r_2,
                                    r_3)\)</span>について、別の基底<span
                                    class="math inline">\(\mathbf{e}&#39;_1,
                                    \mathbf{e}&#39;_2,
                                    \mathbf{e}&#39;_3\)</span>で展開した時の表現<span
                                    class="math inline">\(\mathbf{r} =
                                    {}^t(r&#39;_1, r&#39;_2,
                                    r&#39;_3)\)</span>を求めたい。つまり、以下のように、ある基底での展開係数がわかっている時、別の基底で表現した場合の展開係数を求めたい。</p>
                                    <p><span class="math display">\[
                                    \begin{aligned}
                                    \mathbf{r} &amp;= r_1
                                    \mathbf{e}_1  +r_1 \mathbf{e}_2+r_3
                                    \mathbf{e}_3\\
                                    &amp;= r&#39;_1
                                    \mathbf{e}&#39;_1  +r&#39;_1
                                    \mathbf{e}&#39;_2+r&#39;_3
                                    \mathbf{e}&#39;_3\\
                                    \end{aligned}
                                    \]</span></p>
                                    <p>もし、それぞれの基底が正規直交基底であるならば、任意のベクトルと基底の内積を取ることで、その基底方向への成分を得ることができる。</p>
                                    <p>例えば、基底ベクトル<span
                                    class="math inline">\(\mathbf{e}&#39;_1\)</span>に対する成分<span
                                    class="math inline">\(r&#39;_1\)</span>を知りたければ、<span
                                    class="math inline">\(\mathbf{e}&#39;_1\)</span>と<span
                                    class="math inline">\(\mathbf{r}\)</span>との内積を取ればよい。</p>
                                    <p><span class="math display">\[
                                    r&#39;_1 = \mathbf{e}&#39;_1 \cdot
                                    \mathbf{r}
                                    \]</span></p>
                                    <p>さて、<span
                                    class="math inline">\(\mathbf{r}\)</span>を基底<span
                                    class="math inline">\(\mathbf{e}_i\)</span>で展開しておき、左から別の基底<span
                                    class="math inline">\(\mathbf{e}&#39;_j\)</span>との内積を取ろう。</p>
                                    <p><span class="math display">\[
                                    \begin{aligned}
                                    r&#39;_j &amp;= \mathbf{e}&#39;_j
                                    \cdot \mathbf{r}  \\
                                    &amp;= \sum_i r_i \mathbf{e}&#39;_j
                                    \cdot  \mathbf{e}_i
                                    \end{aligned}
                                    \]</span></p>
                                    <p>この式は「あるベクトル<span
                                    class="math inline">\(\mathbf{r}\)</span>について、ある基底<span
                                    class="math inline">\(\mathbf{e}_i\)</span>での展開係数がわかっている場合、別の基底<span
                                    class="math inline">\(\mathbf{e}&#39;_j\)</span>での展開係数を知るには、基底同士の内積
                                    <span
                                    class="math inline">\(\mathbf{e}&#39;_j
                                    \cdot \mathbf{e}_i\)</span>
                                    がわかっていればいれば良い」ということを意味する。</p>
                                    <p>このように、ベクトルをある基底から別の基底で表現しなおすことを基底変換と呼ぶ。物理学において基底変換は極めて重要であり、解析力学においてもその変換性を議論する。それは、「物理法則が座標変換をしても形を変えてはならない」ことを要請するからである。この事情については後述する。</p>
                                    <h2
                                    id="ベクトル空間の定義">ベクトル空間の定義</h2>
                                    <p>先ほどまで、ベクトルを「複数個の値の組」として捉えていた。しかし、今後はベクトルの概念を拡張し、より一般的に様々なものをベクトルとして扱う。まず、ベクトルとはどういうものであったかを確認しみよう。いま、2つのベクトル<span
                                    class="math inline">\(\mathbf{u},
                                    \mathbf{v}\)</span>があったとして、その和<span
                                    class="math inline">\(\mathbf{u}+\mathbf{v}\)</span>もベクトルである。また、それぞれの定数倍、<span
                                    class="math inline">\(a \mathbf{u},
                                    b
                                    \mathbf{v}\)</span>もベクトルだ。当然、その和である<span
                                    class="math inline">\(a \mathbf{u} +
                                    b
                                    \mathbf{v}\)</span>もベクトルとなる。このように、ベクトルをそれぞれ定数倍して加えることを
                                    <strong>線形結合(linear
                                    combination)</strong>
                                    と呼ぶ。さて、ベクトルと同様に線形結合、すなわち「定数倍して足す」ことができるものは他にもある。例えば行列もそうだし、関数や微分演算子も線形結合ができる。これらを統一的に扱えたら便利な気がするであろう。そこで逆に「線形結合できるもの」をベクトルと呼ぶことにしよう。</p>
                                    <p>この「線形結合できる」という性質をきちんと定義しよう。線形結合とは「定数倍して和をとる」ことであるから、まず定数倍するための適当なスカラー<span
                                    class="math inline">\(a,
                                    b\)</span>を用意する。これは実数や複素数である。また、定数倍したり和をとったりするための要素を含む集合<span
                                    class="math inline">\(\mathbb{V}\)</span>を考えよう。この集合の任意の元<span
                                    class="math inline">\(\mathbf{u},
                                    \mathbf{v}, \mathbf{w} \in
                                    \mathbb{V}\)</span>が、以下の8つの性質を満たすとき、集合<span
                                    class="math inline">\(\mathbb{V}\)</span>をベクトル空間、その元をベクトルと呼ぶ。</p>
                                    <ol type="1">
                                    <li>ベクトルの和が結合律を満たす
                                    <span
                                    class="math inline">\(\mathbf{u} +
                                    (\mathbf{v} + \mathbf{w}) =
                                    (\mathbf{u} + \mathbf{v}) +
                                    \mathbf{w}\)</span></li>
                                    <li>ベクトルの和が可換である <span
                                    class="math inline">\(\mathbf{u} +
                                    \mathbf{v} = \mathbf{v} +
                                    \mathbf{u}\)</span></li>
                                    <li>零ベクトル(加法の単位元)が存在する
                                    <span
                                    class="math inline">\(\mathbf{v} +
                                    \mathbf{0} =
                                    \mathbf{v}\)</span></li>
                                    <li>ベクトルの加法に逆元が存在する(任意のベクトルに、和をとると零ベクトルにできるベクトルが存在する)
                                    <span
                                    class="math inline">\(\mathbf{v} +
                                    (- \mathbf{v}) = 0\)</span></li>
                                    <li>スカラーの乗法がベクトルに対して分配律を満たす
                                    <span class="math inline">\(a
                                    (\mathbf{u} + \mathbf{v}) = a
                                    \mathbf{u} + a
                                    \mathbf{v}\)</span></li>
                                    <li>スカラーの加法と乗法が分配律を満たす
                                    <span class="math inline">\((a+b)
                                    \mathbf{u} = a \mathbf{u} + b
                                    \mathbf{u}\)</span></li>
                                    <li>スカラーとベクトルの乗法とスカラー同士の乗法が結合律を満たす
                                    <span
                                    class="math inline">\(a(b\mathbf{u})
                                    = (ab) \mathbf{u}\)</span></li>
                                    <li>スカラー乗法に単位元が存在する
                                    <span class="math inline">\(1
                                    \mathbf{u} =
                                    \mathbf{u}\)</span></li>
                                    </ol>
                                    <p>以上の8つをベクトル空間の
                                    <strong>公理(axiom)</strong>
                                    と呼ぶ。</p>
                                    <p>3次元ベクトルは明らかにこの定義を満たしているが、例えば任意の関数<span
                                    class="math inline">\(f(x)\)</span>もベクトルの定義を満たす。例えば<span
                                    class="math inline">\(\mathbb{V}\)</span>として位置変数関数全体の集合をとし、適当な関数<span
                                    class="math inline">\(f(x)\)</span>と<span
                                    class="math inline">\(g(x)\)</span>をその要素とすると、<span
                                    class="math inline">\(f(x)\)</span>と<span
                                    class="math inline">\(g(x)\)</span>の線形結合により新たな関数</p>
                                    <p><span class="math display">\[
                                    h(x) = af(x) + bg(x)
                                    \]</span></p>
                                    <p>を作ることができる。明らかに<span
                                    class="math inline">\(h(x)\)</span>も<span
                                    class="math inline">\(\mathbb{V}\)</span>の元である。また、関数全体の集合と実数や複素数係数との組み合わせがベクトル空間の公理を満たすことはすぐにわかるであろう。</p>
                                    <h2 id="テンソル積">テンソル積</h2>
                                    <p>ベクトルには標準基底を考えることができた。では、行列に同様な基底はあるのだろうか？また、その基底はどのように定義されるのだろうか？その疑問に答えるのがテンソル積である。</p>
                                    <p>基底<span
                                    class="math inline">\(\mathbf{e}_1\)</span>と、その相方とのクロネッカー積<span
                                    class="math inline">\(\mathbf{e}^1
                                    \otimes
                                    \mathbf{e}_1\)</span>を以下のように定義する。</p>
                                    <p><span class="math display">\[
                                    \begin{aligned}
                                    \mathbf{e}^1 \otimes \mathbf{e}_1
                                    &amp;=
                                    \begin{pmatrix}
                                    1 &amp; 0 &amp; 0
                                    \end{pmatrix}
                                    \otimes
                                    \begin{pmatrix}
                                    1\\ 0\\0
                                    \end{pmatrix}
                                    =
                                    \end{aligned}
                                    \begin{pmatrix}
                                    1 &amp; 0 &amp; 0 \\
                                    0 &amp; 0 &amp; 0 \\
                                    0 &amp; 0 &amp; 0
                                    \end{pmatrix}
                                    \]</span></p>
                                    <p>3行3列の行列の1行目1列目の要素が1、それ以外が0となるような行列となっていることがわかる。全く同様に<span
                                    class="math inline">\(\mathbf{e}^i
                                    \otimes
                                    \mathbf{e}_j\)</span>を定義することができ、これが<span
                                    class="math inline">\(j\)</span>行目の<span
                                    class="math inline">\(i\)</span>列目の要素を表現する。このようにただ一つの要素が1、それ以外が0となるような行列を
                                    <strong>行列単位(matrix
                                    unit)</strong>
                                    と呼ぶ。ベクトルが標準基底ベクトルで自然に展開できたように、行列も行列単位によって自然に展開することができる。</p>
                                    <p><span class="math display">\[
                                    \begin{aligned}
                                    A &amp;=
                                    \begin{pmatrix}
                                    A^1_1 &amp; A^1_2 &amp; A^1_3 \\
                                    A^2_1 &amp; A^2_2 &amp; A^2_3 \\
                                    A^3_1 &amp; A^3_2 &amp; A^3_3
                                    \end{pmatrix}
                                    = \sum_{i=1}^{3} \sum_{j=1}^{3}
                                    A^j_i \mathbf{e}^i \otimes
                                    \mathbf{e}_j
                                    \end{aligned}
                                    \]</span></p>
                                    <p>すなわち行列単位が行列の標準基底の役割を果たしていることがわかる。</p>
                                    <p>今、3次元縦ベクトルと3次元横ベクトルから、3行3列の行列を作ることができた。このように、2つのベクトル空間から新たなベクトル空間を作る操作を
                                    <strong>テンソル積(tensor
                                    product)</strong>
                                    と呼ぶ。クロネッカー積はテンソル積の表現の一つである。</p>
                                    <p>さて、多くの場合において、和の範囲は自明である。例えば3次元空間において<span
                                    class="math inline">\(i\)</span>が軸に関するものであれば、和の範囲は1から3までであろうし、<span
                                    class="math inline">\(N\)</span>粒子系において<span
                                    class="math inline">\(i\)</span>が粒子番号であれば、範囲は<span
                                    class="math inline">\(1\)</span>から<span
                                    class="math inline">\(N\)</span>まで走るであろう。その場合にいちいち和記号<span
                                    class="math inline">\(\Sigma\)</span>を書くのは面倒である。そこで、同じ添字が2つ現れたら、その添字について和を取る、という約束をする。これを
                                    <strong>アインシュタイン記法(Einstein
                                    notation)</strong> と呼ぶ。</p>
                                    <p>先程の行列の展開の式は、アインシュタイン記法を用いると以下のようにかける。</p>
                                    <p><span class="math display">\[
                                    \begin{aligned}
                                    A &amp;=
                                    \begin{pmatrix}
                                    A^1_1 &amp; A^1_2 &amp; A^1_3 \\
                                    A^2_1 &amp; A^2_2 &amp; A^2_3 \\
                                    A^3_1 &amp; A^3_2 &amp; A^3_3
                                    \end{pmatrix}
                                    = A^j_i \mathbf{e}^i \otimes
                                    \mathbf{e}_j
                                    \end{aligned}
                                    \]</span></p>
                                    <p>ベクトルや行列を要素表現した時の添字の数を「足」と呼ぶ。ベクトルのテンソル積を考えることで足を増やすことができる。ベクトルは足が1本であり、行列は足が2本である。ベクトルのテンソル積により作られた世界は、元になったベクトルよりも広い世界になっている。例えば3次元縦ベクトルと横ベクトルのテンソル積は、3行3列の行列、すなわち9次元の空間になっている。このベクトルや行列をまとめて
                                    <strong>テンソル(tensor)</strong>
                                    と呼ぶ。足の本数、つまり添字の数をテンソルの階数と呼ぶ。ベクトルは1階のテンソル、行列は2階のテンソルである。テンソル積により、いくらでも高階のテンソルを作ることができる。</p>
                                    <p>テンソルは様々なところに現れる。例えば連続体の力学では応力テンソルが重要な役割を果たす。一方、テンソルは抽象的な概念であり、なかなかイメージすることが難しい。まずは内積を通じてテンソルを理解しておくと良い。</p>
                                    <p>横ベクトル<span
                                    class="math inline">\(\mathbf{a}\)</span>と、縦ベクトル<span
                                    class="math inline">\(\mathbf{b}\)</span>の内積を考える。簡単のため、3次元ベクトルとしよう。それぞれ要素と基底を明示すると、</p>
                                    <p><span class="math display">\[
                                    \begin{aligned}
                                    \mathbf{a} &amp;=
                                    \begin{pmatrix}
                                    a_1 &amp; a_2 &amp; a_3
                                    \end{pmatrix}\\
                                    &amp;= a_i \mathbf{e}^i
                                    \end{aligned}
                                    \]</span></p>
                                    <p><span class="math display">\[
                                    \begin{aligned}
                                    \mathbf{b} &amp;=
                                    \begin{pmatrix}
                                    b^1 \\
                                    b^2\\
                                    b^3
                                    \end{pmatrix}\\
                                    &amp;= b^j \mathbf{e}_j
                                    \end{aligned}
                                    \]</span></p>
                                    <p>これらの内積を取ると</p>
                                    <p><span class="math display">\[
                                    \begin{aligned}
                                    (\mathbf{a}, \mathbf{b}) &amp;= a_i
                                    b^j (\mathbf{e}^i, \mathbf{e}_j)\\
                                    &amp;= a_i b^j \delta^i_j \\
                                    &amp;= a_i b^i
                                    \end{aligned}
                                    \]</span></p>
                                    <p>となる。ここでアインシュタイン記法を使っていることに注意。上下の足がつぶれて足のない数、すなわちスカラーになっている。</p>
                                    <p>同様に、行列<span
                                    class="math inline">\(A\)</span>と、縦ベクトルの標準基底の一つ<span
                                    class="math inline">\(\mathbf{e}_k\)</span>の内積<span
                                    class="math inline">\((A,
                                    \mathbf{e}_k)\)</span>を考えよう。行列<span
                                    class="math inline">\(A\)</span>は、縦ベクトルと横ベクトルのテンソル積で展開できるのであるから、</p>
                                    <p><span class="math display">\[
                                    (A, \mathbf{e}_k) = (A^j_i
                                    \mathbf{e}^i \otimes \mathbf{e}_j,
                                    \mathbf{e}_k)
                                    \]</span></p>
                                    <p>ここで、横ベクトルと縦ベクトルの内積が</p>
                                    <p><span class="math display">\[
                                    (\mathbf{e}^i, \mathbf{e}_k) =
                                    \delta^i_k
                                    \]</span></p>
                                    <p>を満たすことから、<span
                                    class="math inline">\(i=k\)</span>のところだけが残り、</p>
                                    <p><span class="math display">\[
                                    \begin{aligned}
                                    (A, \mathbf{e}_k) &amp;= (A^j_i
                                    \mathbf{e}^i \otimes \mathbf{e}_j,
                                    \mathbf{e}_k)\\
                                    &amp;= A^j_i \delta^i_k
                                    \mathbf{e}_j\\
                                    &amp;= A^j_k \mathbf{e}_j
                                    \end{aligned}
                                    \]</span></p>
                                    <p>となる。これは縦ベクトルである。つまり、行列と縦ベクトルの内積をとると、行列を構成していた横ベクトルの成分と相殺して、縦ベクトルが残る、と解釈できる。同様に、行列と横ベクトルの内積を取ると、縦ベクトルの成分と相殺して横ベクトルが出てくる。</p>
                                    <p>ここでは、2階のテンソルとして縦ベクトルと横ベクトルのテンソル積を考えたが、縦ベクトル2つのテンソル積を考えることもできる。その場合は添字が2つとも上付きとなる。</p>
                                    <p><span class="math display">\[
                                    A = A^{ij} \mathbf{e}_i \otimes
                                    \mathbf{e}_j
                                    \]</span></p>
                                    <p>こうして作られたテンソルは、行列のようには表現できないが、「横ベクトルと内積をとると横ベクトルとなり、さらに横ベクトルと内積をとるとスカラーになるもの」と理解できる。このように、テンソルがイメージできないうちは「上下の逆側の足を持つベクトルと内積をとると、その足が潰せるもの」と理解しておくと良い。</p>
                                    <h2 id="内積空間">内積空間</h2>
                                    <p>ベクトル空間とは、要素の線形結合ができる世界のことである。これにより、いわゆる「向きと大きさ」を持ったベクトルだけでなく、関数や微分演算子などもベクトルとみなすことができる。</p>
                                    <p>さて、物理で現れるベクトル空間には、自然な内積が定義できることが多い。内積が定義されたベクトル空間を
                                    <strong>内積空間(inner product
                                    space)</strong>
                                    と呼ぶ。内積とは、ベクトル2つを、1つのスカラーに結びつける写像のことである。既に見たように、縦ベクトルや横ベクトルには自然な内積が定義できるが、関数をベクトルとみなすと、関数同士にも内積も定義することができる。いま、関数<span
                                    class="math inline">\(f(x)\)</span>と<span
                                    class="math inline">\(g(x)\)</span>について、その内積を</p>
                                    <p><span class="math display">\[
                                    (f,g) =
                                    \int_{-\infty}^{\infty}f^*(x)g(x)dx
                                    \]</span></p>
                                    <p>により定義する。ただし<span
                                    class="math inline">\(f^*(x)\)</span>は<span
                                    class="math inline">\(f(x)\)</span>の複素共役である。これにより、ベクトル2つからスカラーを結びつけることができる。このように関数をベクトルとみなし、ある基底から別の基底での表現を得るのがフーリエ変換である。</p>
                                    <p>次に、微分演算子に関する内積を考えよう。変数<span
                                    class="math inline">\(x\)</span>と<span
                                    class="math inline">\(y\)</span>にのみ依存する2変数関数<span
                                    class="math inline">\(f(x,y)\)</span>を考える。<span
                                    class="math inline">\(x\)</span>と<span
                                    class="math inline">\(y\)</span>が時間<span
                                    class="math inline">\(t\)</span>に依存している時、すなわち<span
                                    class="math inline">\(f(x(t),
                                    y(t))\)</span>と書ける時、<span
                                    class="math inline">\(f\)</span>の時間微分は</p>
                                    <p><span class="math display">\[
                                    \frac{df}{dt} = \frac{\partial
                                    f}{\partial x} \frac{dx}{dt} +
                                    \frac{\partial f}{\partial y}
                                    \frac{dy}{dt}
                                    \]</span></p>
                                    <p>さて、<span
                                    class="math inline">\(f(x,y)\)</span>は<span
                                    class="math inline">\(x\)</span>と<span
                                    class="math inline">\(y\)</span>にしか依存していないので、<span
                                    class="math inline">\(x\)</span>や<span
                                    class="math inline">\(y\)</span>が<span
                                    class="math inline">\(t\)</span>ではなく<span
                                    class="math inline">\(s\)</span>に依存していても式の形は全く変わらない。</p>
                                    <p><span class="math display">\[
                                    \frac{df}{ds} = \frac{\partial
                                    f}{\partial x} \frac{dx}{ds} +
                                    \frac{\partial f}{\partial y}
                                    \frac{dy}{ds}
                                    \]</span></p>
                                    <p>そこで、<span
                                    class="math inline">\(dt\)</span>や<span
                                    class="math inline">\(ds\)</span>を形式的に消して、以下のように書いてみる。</p>
                                    <p><span class="math display">\[
                                    df = \frac{\partial f}{\partial x}
                                    dx
                                    + \frac{\partial f}{\partial y} dy
                                    \]</span></p>
                                    <p>このように書ける時、<span
                                    class="math inline">\(f\)</span>は全微分可能であると言い、この表式を<span
                                    class="math inline">\(f\)</span>の
                                    <strong>全微分(total
                                    derivative)</strong> と呼ぶ。</p>
                                    <p>さて、この式の意味を考えよう。<span
                                    class="math inline">\(f(x,y)\)</span>という関数を、点<span
                                    class="math inline">\((x,y)\)</span>の周りでテイラー展開し、一次の項目だけ残す。</p>
                                    <p><span class="math display">\[
                                    f(x+\delta x, y+\delta y) - f(x,y)
                                    \sim \frac{\partial f}{\partial x}
                                    \delta x +
                                    \frac{\partial f}{\partial y} \delta
                                    y
                                    \]</span></p>
                                    <p>つまり、<span
                                    class="math inline">\(\partial
                                    f/\partial
                                    x\)</span>という量は、<span
                                    class="math inline">\(y\)</span>を変化させずに、<span
                                    class="math inline">\(x\)</span>だけを変化させた場合の<span
                                    class="math inline">\(f\)</span>の変化の割合であった。そこで、全微分の両辺を形式的に<span
                                    class="math inline">\(dx\)</span>でわろう。この時、微分記号が偏微分に化ける。</p>
                                    <p><span class="math display">\[
                                    \begin{aligned}
                                    \frac{\partial f}{\partial x} &amp;=
                                    \frac{\partial f}{\partial x}
                                    \underbrace{\frac{\partial
                                    x}{\partial x}}_{=1}
                                    + \frac{\partial f}{\partial y}
                                    \underbrace{\frac{\partial
                                    y}{\partial x}}_{=0} \\
                                    &amp;= \frac{\partial f}{\partial x}
                                    \end{aligned}
                                    \]</span></p>
                                    <p>この事実をもって、もう一度先の全微分の式を眺めてみる。</p>
                                    <p><span class="math display">\[
                                    df = \frac{\partial f}{\partial x}
                                    dx
                                    + \frac{\partial f}{\partial y} dy
                                    \]</span></p>
                                    <p>すると、これがまるでベクトルを基底で展開しているかのように見える。また、<span
                                    class="math inline">\(dx\)</span>の内積をとる相方が<span
                                    class="math inline">\(\partial_x\)</span>であることもわかる。</p>
                                    <p>となる。以上から、<span
                                    class="math inline">\(df\)</span>をベクトル、<span
                                    class="math inline">\(dx\)</span>や<span
                                    class="math inline">\(dy\)</span>を基底のように扱うことができることがわかる。さらに、<span
                                    class="math inline">\(dx\)</span>をベクトルと見た時、その相方となるベクトルが<span
                                    class="math inline">\(\partial_x\)</span>であることもわかる。すなわち、<span
                                    class="math inline">\(dx, dy,
                                    dz\)</span>と<span
                                    class="math inline">\(\partial_x,
                                    \partial_y,
                                    \partial_z\)</span>の間には、自然な内積、</p>
                                    <p><span class="math display">\[
                                    \left&lt;d\alpha,\frac{\partial}{\partial
                                    \beta}\right&gt; = \frac{\partial
                                    \alpha}{\partial \beta} =
                                    \delta_{\alpha, \beta}
                                    \]</span></p>
                                    <p>が定義される。このように、<span
                                    class="math inline">\(dx,
                                    dy\)</span>を横ベクトル、<span
                                    class="math inline">\(\partial_x,
                                    \partial_y\)</span>を縦ベクトルだと思うことができ、それらの間に内積を定義することができた。このように考えると、<span
                                    class="math inline">\(dx,
                                    dy\)</span>が住む世界と<span
                                    class="math inline">\(\partial_x,
                                    \partial_y\)</span>が住む世界は双対空間である。</p>
                                    <h1
                                    id="微分と偏微分">微分と偏微分</h1>
                                    <p>力学は微分方程式を解く学問であるから、当然微積分が出てくる。特に合成関数の微分や、ベクトルによる微分などが現れるので、ここで簡単に確認しておこう。</p>
                                    <h2
                                    id="微分の表記方法">微分の表記方法</h2>
                                    <p>微分の記法にはいくつか方法がある。関数<span
                                    class="math inline">\(f(x)\)</span>の<span
                                    class="math inline">\(x\)</span>による導関数は</p>
                                    <p><span class="math display">\[
                                    \frac{d}{dx} f(x), \frac{d
                                    f(x)}{dx}, \frac{df}{dx}
                                    \]</span></p>
                                    <p>などと分数の形で表記する。この表記を
                                    <strong>ライプニッツ記法(Leibniz’s
                                    notation)</strong> と呼ぶ<a
                                    href="#fn1" class="footnote-ref"
                                    id="fnref1"
                                    role="doc-noteref"><sup>1</sup></a>。</p>
                                    <p>ライプニッツ記法では、何を何で微分したかが明記されているため混乱が少ないが、式が複雑であるときに煩わしいことがある。そこで、本講義では適宜、別の記法も用いることにする。</p>
                                    <p>まず関数<span
                                    class="math inline">\(f(x)\)</span>を見ると、<span
                                    class="math inline">\(f\)</span>という値が<span
                                    class="math inline">\(x\)</span>という引数に依存していることがわかる。したがって、<span
                                    class="math inline">\(f(x)\)</span>を微分しようとしたら<span
                                    class="math inline">\(x\)</span>に決まっているので、以下のようにプライム記号で表記する。</p>
                                    <p><span class="math display">\[
                                    f&#39;(x) \equiv \frac{df}{dx}
                                    \]</span></p>
                                    <p>二階微分や三階微分は</p>
                                    <p><span class="math display">\[
                                    \begin{aligned}
                                    f&#39;&#39;(x) &amp;\equiv
                                    \frac{d^2f}{dx^2}\\
                                    f&#39;&#39;&#39;(x) &amp;\equiv
                                    \frac{d^3f}{dx^3}\\
                                    \end{aligned}
                                    \]</span></p>
                                    <p>とプライム記号を増やして表記する。このような表記を
                                    <strong>ラグランジュ記法(Lagrange’s
                                    notation)</strong> と呼ぶ。<a
                                    href="#fn2" class="footnote-ref"
                                    id="fnref2"
                                    role="doc-noteref"><sup>2</sup></a></p>
                                    <p>それ以上の高階微分や、<span
                                    class="math inline">\(n\)</span>階微分など微分回数が変数である場合は</p>
                                    <p><span class="math display">\[
                                    \begin{aligned}
                                    f^{(4)}(x) &amp;\equiv \frac{d^4
                                    f}{dx^4}\\
                                    f^{(n)}(x) &amp;\equiv \frac{d^n
                                    f}{dx^n}
                                    \end{aligned}
                                    \]</span></p>
                                    <p>などと表記するが、力学においてはほとんど高階微分は出てこないので気にしなくて良い。なお、扱う記号はプライム「’」であるが、<span
                                    class="math inline">\(f&#39;(x)\)</span>を「エフダッシュエックス」と呼ぶことがある(余談参照)。</p>
                                    <p>さて、力学は物体の運動、すなわち時間変化を追う学問である。したがって、時間微分が頻出する。そこで、時間微分をドットで表記することにする。二階微分は二重ドットで表記する。</p>
                                    <p><span class="math display">\[
                                    \begin{aligned}
                                    \dot{x} &amp;\equiv \frac{dx}{dt} \\
                                    \ddot{x} &amp;\equiv
                                    \frac{d^2x}{dt^2}
                                    \end{aligned}
                                    \]</span></p>
                                    <p>これを
                                    <strong>ニュートン記法(Newton’s
                                    notation)</strong> と呼ぶ。<a
                                    href="#fn3" class="footnote-ref"
                                    id="fnref3"
                                    role="doc-noteref"><sup>3</sup></a>
                                    高階数微分ではドットの上に数を書く表記もあるが、ほとんどの場合において二階微分までしか扱わないため、二重ドット表記まで覚えれば良い。</p>
                                    <p>これらの表記が複合する場合がある。例えば位置<span
                                    class="math inline">\(x\)</span>は時間の関数であり、力<span
                                    class="math inline">\(f\)</span>は位置の関数であるとき、<span
                                    class="math inline">\(f(x)\)</span>を時間で微分したもののライプニッツ表記は</p>
                                    <p><span class="math display">\[
                                    \frac{df }{dt} = \frac{df}{dx}
                                    \frac{dx}{dt}
                                    \]</span></p>
                                    <p>となる。これは</p>
                                    <p><span class="math display">\[
                                    \frac{df}{dt} = f&#39;(x) \dot{x}
                                    \]</span></p>
                                    <p>と表記できる。関数を、その引数で微分する場合はラグランジュ記法が、時間に関する変数<span
                                    class="math inline">\(x\)</span>の時間微分はニュートン記法が使われている。ややこしいようにも見えるが、慣れてしまえば表記が簡略化される分、読みやすくなる。</p>
                                    <h2 id="偏微分">偏微分</h2>
                                    <p>関数の微分とは、現在の場所と、少しずれた場所との差の極限であった。関数が複数の変数に依存している場合、「どの方向に少しずれるのか」を指定する必要がある。例えば斜面に立っている時、どの方向に足を踏み出すかによって一歩でどれだけ高さが変化するかが変わるため、どの方向に足を踏み出すかを定義する必要がある。いま、２つの変数<span
                                    class="math inline">\(x,y\)</span>に依存する関数<span
                                    class="math inline">\(f(x,y)\)</span>があるとする。ここで<span
                                    class="math inline">\(y\)</span>を固定して<span
                                    class="math inline">\(x\)</span>だけをずらした時の微分係数を<span
                                    class="math inline">\(x\)</span>に関する偏微分係数と呼び、以下のように定義する。</p>
                                    <p><span class="math display">\[
                                    \frac{\partial f}{\partial x} \equiv
                                    \lim_{h \rightarrow 0}
                                    \frac{f(x + h , y) - f(x,y)}{h}
                                    \]</span></p>
                                    <p><span
                                    class="math inline">\(y\)</span>に関する偏微分係数も同様に定義する。以後、<span
                                    class="math inline">\(x\)</span>に関する偏微分演算子<span
                                    class="math inline">\(\partial/\partial_x\)</span>を、<span
                                    class="math inline">\(\partial_x\)</span>のように略記することがある。</p>
                                    <p>偏微分する際、どの変数を固定しているのかを明示したい場合は、</p>
                                    <p><span class="math display">\[
                                    \left(\frac{\partial f}{\partial
                                    x}\right)_y
                                    \]</span></p>
                                    <p>のように括弧の外に書く場合がある。熱力学ではどの変数を固定しているかが重要であるが、解析力学では自明であることが多いので本書では省略する。</p>
                                    <h2
                                    id="ベクトル解析">ベクトル解析</h2>
                                    <p>次に、ベクトルが絡んだ微分について考えよう。多くの場合、力学では3次元空間を扱うため、座標や速度、力は3次元ベクトルとなる。また、ポテンシャルエネルギーはスカラー量であるが、位置の関数であるから引数としてベクトルを取る。これらを微分すると、スカラーとベクトルが入り交じることになる。以後、混乱しないように、表記の確認をしておこう。</p>
                                    <p>質点の位置が<span
                                    class="math inline">\(\mathbf{r} =
                                    {}^t(x,y,z)\)</span>で表されており、その位置に依存するスカラー関数<span
                                    class="math inline">\(f(\mathbf{r})\)</span>があるとしよう。ただし、<span
                                    class="math inline">\(f\)</span>は<span
                                    class="math inline">\(t\)</span>には陽には依存しないとする。この関数は、ベクトルを食わせるとスカラーを返す関数である。たとえば場所に依存する温度のようなものを想像すれば良い。この量の微分を考える。<span
                                    class="math inline">\(f\)</span>は<span
                                    class="math inline">\(x,y,z\)</span>に依存する関数であるから、</p>
                                    <p><span class="math display">\[
                                    \frac{df}{dt} = \frac{\partial
                                    f}{\partial x} \dot{x}
                                    +\frac{\partial f}{\partial y}
                                    \dot{y}
                                    +\frac{\partial f}{\partial z}
                                    \dot{z}
                                    \]</span></p>
                                    <p>三次元空間では、このように<span
                                    class="math inline">\(x, y,
                                    z\)</span>座標での偏微分が頻繁に現れる。これらを毎回書くのは面倒であるので、以下のような<span
                                    class="math inline">\(\nabla\)</span>(ナブラ)という演算子を定義する。</p>
                                    <p><span class="math display">\[
                                    \nabla =
                                    \begin{pmatrix}
                                    \frac{\partial}{\partial x} \\
                                    \frac{\partial}{\partial y} \\
                                    \frac{\partial}{\partial z}
                                    \end{pmatrix}
                                    \]</span></p>
                                    <p>ナブラは成分に微分演算子が含まれているベクトルである。ベクトルであるから、スカラーに作用させるとベクトル量になる。</p>
                                    <p><span class="math display">\[
                                    \nabla f =
                                    \begin{pmatrix}
                                    \frac{\partial f}{\partial x} \\
                                    \frac{\partial f}{\partial y} \\
                                    \frac{\partial f}{\partial z}
                                    \end{pmatrix}
                                    \]</span></p>
                                    <p>ここで、速度ベクトル</p>
                                    <p><span class="math display">\[
                                    \dot{\mathbf{r}} =
                                    \begin{pmatrix}
                                    \dot{x} \\
                                    \dot{y} \\
                                    \dot{z}
                                    \end{pmatrix}
                                    \]</span></p>
                                    <p>を定義すると、先程の<span
                                    class="math inline">\(f\)</span>の時間微分は以下のように表記できる。</p>
                                    <p><span class="math display">\[
                                    \frac{df}{dt} = (\nabla f) \cdot
                                    \dot{\mathbf{r}}
                                    \]</span></p>
                                    <p><span
                                    class="math inline">\(\nabla\)</span>を使う簡単な例として太陽系を考えよう。太陽質量を<span
                                    class="math inline">\(M\)</span>、地球の質量を<span
                                    class="math inline">\(m\)</span>とし、地球の座標を<span
                                    class="math inline">\((x,y)\)</span>とする。宇宙空間は3次元だが、公転面を考えることで2次元系を考える。さらに、太陽が動かないと近似しよう。太陽質量は地球の33万倍なので、これは非常に良い近似である。この系の運動方程式は以下のようになる。</p>
                                    <p><span class="math display">\[
                                    \begin{aligned}
                                    m \frac{d^2x}{dt^2} &amp;=  -G
                                    \frac{Mmx}{r^3} \\
                                    m \frac{d^2y}{dt^2} &amp;=  -G
                                    \frac{Mmy}{r^3}
                                    \end{aligned}
                                    \]</span></p>
                                    <p>ただし、<span
                                    class="math inline">\(r = \sqrt{x^2
                                    +
                                    y^2}\)</span>である。これをベクトルの言葉で書いていきたい。</p>
                                    <p>まず、重力は保存力なので、ポテンシャルエネルギー<span
                                    class="math inline">\(V(r)\)</span>を考えよう。</p>
                                    <p><span class="math display">\[
                                    V(r) = -\frac{GMm}{r}
                                    \]</span></p>
                                    <p>これを<span
                                    class="math inline">\(x\)</span>で偏微分すると</p>
                                    <p><span class="math display">\[
                                    \frac{\partial V}{\partial x} =
                                    V&#39;(r) \frac{\partial r}{\partial
                                    x}
                                    \]</span></p>
                                    <p><span class="math display">\[
                                    r^2 = x^2 + y^2
                                    \]</span></p>
                                    <p>の両辺を<span
                                    class="math inline">\(x\)</span>で偏微分して、</p>
                                    <p><span class="math display">\[
                                    2r \frac{\partial r}{\partial x} = 2
                                    x
                                    \]</span></p>
                                    <p>従って、</p>
                                    <p><span class="math display">\[
                                    \frac{\partial r}{\partial x} =
                                    \frac{x}{r}
                                    \]</span></p>
                                    <p>以上から、</p>
                                    <p><span class="math display">\[
                                    \frac{\partial V}{\partial x} = G
                                    \frac{Mmx}{r^3}
                                    \]</span></p>
                                    <p><span
                                    class="math inline">\(y\)</span>も同様である。ここから運動方程式は</p>
                                    <p><span class="math display">\[
                                    \begin{aligned}
                                    m \frac{d^2x}{dt^2} &amp;=  -
                                    \frac{\partial V}{\partial x} \\
                                    m \frac{d^2y}{dt^2} &amp;=  -
                                    \frac{\partial V}{\partial y}
                                    \end{aligned}
                                    \]</span></p>
                                    <p>さらに、地球の座標をベクトルで表そう。</p>
                                    <p><span class="math display">\[
                                    \mathbf{r} =
                                    \begin{pmatrix}
                                    x \\ y
                                    \end{pmatrix}
                                    \]</span></p>
                                    <p>すると、先程の運動方程式は以下のように一行にまとめられる。</p>
                                    <p><span class="math display">\[
                                    \begin{aligned}
                                    m \frac{d^2 \mathbf{r}}{dt^2} &amp;=
                                    - \nabla V
                                    \end{aligned}
                                    \]</span></p>
                                    <p>両辺ともにベクトルで有ることに注意。</p>
                                    <p><span
                                    class="math inline">\(\nabla\)</span>を<span
                                    class="math inline">\(d/
                                    d\mathbf{r}\)</span>と表現すれば</p>
                                    <p><span class="math display">\[
                                    \begin{aligned}
                                    m \frac{d^2 \mathbf{r}}{dt^2} &amp;=
                                    -\frac{d V}{d \mathbf{r}}
                                    \end{aligned}
                                    \]</span></p>
                                    <p>となり、一次元空間での運動方程式</p>
                                    <p><span class="math display">\[
                                    \begin{aligned}
                                    m \frac{d^2 r}{dt^2} &amp;= -\frac{d
                                    V}{d r}
                                    \end{aligned}
                                    \]</span></p>
                                    <p>と同じ形で表現できる。</p>
                                    <p><span
                                    class="math inline">\(\nabla\)</span>はベクトルであるから、普通のベクトルのようにスカラー倍もできるし、ベクトルと内積をとればスカラー量に、外積を取ればベクトル量になる。</p>
                                    <p>先程見たように、スカラー場に<span
                                    class="math inline">\(\nabla\)</span>を適用するとベクトル場を得る。これは勾配(gradient)と呼ばれ<span
                                    class="math inline">\(\mathrm{grad}\)</span>で表記することがある。</p>
                                    <p><span class="math display">\[
                                    \mathrm{grad} f \equiv \nabla f
                                    \]</span></p>
                                    <p><span
                                    class="math inline">\(\nabla\)</span>とベクトル場と内積を取るとスカラー場になる。これは発散(divergence)と呼ばれ、<span
                                    class="math inline">\(\mathrm{div}\)</span>で表記することがある。</p>
                                    <p><span class="math display">\[
                                    \mathrm{div} \mathbf{v} \equiv
                                    \nabla \cdot \mathbf{v}
                                    \]</span></p>
                                    <p><span
                                    class="math inline">\(\nabla\)</span>とベクトル場との外積をとるとベクトル場になる。これは回転(rotation)と呼ばれ、<span
                                    class="math inline">\(\mathrm{rot}\)</span>で表記することがある。</p>
                                    <p><span class="math display">\[
                                    \mathrm{rot} \mathbf{v} \equiv
                                    \nabla \times \mathbf{v}
                                    \]</span></p>
                                    <p>これらがなぜ勾配、発散、回転と呼ばれているか、またその物理的な意味については位相空間の節で説明する。</p>
                                    <p>なお、<span
                                    class="math inline">\(\nabla\)</span>は微分演算子であるから、積の順番を交換することはできないことに注意。</p>
                                    <p><span class="math display">\[
                                    \nabla fg \neq f \nabla g.
                                    \]</span></p>
                                    <h1 id="まとめ">まとめ</h1>
                                    <p>本章では、解析力学で現れる数学の最低限の準備を行った。特に、大学で扱う物理数学では、解析学と代数学がお互いに入り交じる。さらに解析力学では幾何学も現れるため、使う数学的ツールは多岐にわたる。出てくる数式は複雑であることが多いが、一つ一つは極めて単純であるため、理解は難しくないであろう。しかし、解析力学は多変数関数の常微分、偏微分が頻出し、「いま何が自由変数で、この変数で偏微分すると何が起きるか」が混乱しがちである。式の導出を曖昧にすると、結局全体の理解があやふやになってしまうので、一つ一つの式変形をきっちり追いかける癖をつけてほしい。</p>
                                    <h1
                                    id="余談ダッシュかプライムか">余談：ダッシュかプライムか</h1>
                                    <p>ラグランジュによる微分記法<span
                                    class="math inline">\(f&#39;(x)\)</span>を「エフダッシュ」と呼ぶべきか「エフプライム」と呼ぶべきかはよく論争になる。田野村忠温氏による調査では、<span
                                    class="math inline">\(a&#39;\)</span>を「a
                                    dash」と読む最も初期の文献が1823年まで遡ることがわかっている。これは「A
                                    Familiar Introduction
                                    to　Crystallography」という、英国で出版された出版物である。一方、<span
                                    class="math inline">\(a&#39;\)</span>を「a
                                    prime」と呼ぶ文献では、1832年に米国で出版された代数学の教科書がある(John
                                    Radford Young An Elementary Treatise
                                    on Algebra, Theoretical and
                                    Practical, First American Edition,
                                    With Additions and Improvements by
                                    Samuel Ward,
                                    1832)。どうやら英国でダッシュ読みが、米国でプライム読みが普及したらしいが、詳細は不明である。</p>
                                    <ul>
                                    <li>参考：<a
                                    href="http://www.tanomura.com/research/papers/tanomura_2018_dash_prime_addenda.pdf">a’
                                    の英語における読みの歴史に関する覚書
                                    ─「ダッシュ、プライム」余論─
                                    田野村忠温</a></li>
                                    </ul>
                                    <aside id="footnotes"
                                    class="footnotes footnotes-end-of-document"
                                    role="doc-endnotes">
                                    <hr />
                                    <ol>
                                    <li
                                    id="fn1"><p>ゴッドフリート・ライプニッツ(Gottfried
                                    Wilhelm Leibniz,
                                    1646-1716)に因む。積分記号なども彼の発明である。<a
                                    href="#fnref1" class="footnote-back"
                                    role="doc-backlink">↩︎</a></p></li>
                                    <li
                                    id="fn2"><p>ジョセフ＝ルイ・ラグランジュ(Joseph-Louis
                                    Lagrange,
                                    1736-1813)に因む。解析力学の創始者の一人である。<a
                                    href="#fnref2" class="footnote-back"
                                    role="doc-backlink">↩︎</a></p></li>
                                    <li
                                    id="fn3"><p>アイザック・ニュートン(1642–1727)に因む。ニュートン力学を構築した。微積分の研究、万有引力の法則や、光学の研究でも有名。<a
                                    href="#fnref3" class="footnote-back"
                                    role="doc-backlink">↩︎</a></p></li>
                                    </ol>
                                    </aside>
                    </article>
    </body>

    </html>